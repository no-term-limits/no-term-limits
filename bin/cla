#!/usr/bin/env bash

function error_handler() {
  >&2 echo "Exited with BAD EXIT CODE '${2}' in ${0} script at line: ${1}."
  exit "$2"
}
trap 'error_handler ${LINENO} $?' ERR
set -o errtrace -o errexit -o nounset -o pipefail

# cla â€” run any folder inside your global Claude devcontainer config (no VS Code required)
# Always uses: ~/projects/github/no-term-limits/dotfiles_no_term_limits/config/cla/.devcontainer

# --- CONFIG --------------------------------------------------------
dc_bin="${DC_BIN:-devcontainer}" # CLI: npm i -g @devcontainers/cli or brew install devcontainer
engine="${ENGINE:-docker}"       # or set ENGINE=podman
global_conf="$HOME/projects/github/no-term-limits/dotfiles_no_term_limits/config/cla"

# --- ARG PARSING ---------------------------------------------------
dotenv=""
envs=()
run_cmd=""
use_shell=1
recreate=0 # if 1, we pass --remove-existing-container

usage() {
  cat <<'EOF'
cla â€” launch the global Claude devcontainer for the current directory

Usage:
  cla                         # bring up container & open a shell
  cla -- cmd                  # run a one-off command instead of interactive shell
  cla --env KEY=VALUE         # inject literal env
  cla --dotenv FILE           # load KEY=VALUE pairs from file
  cla --podman | --docker     # choose engine (default: docker)
  cla --recreate              # force re-create the devcontainer (refresh containerEnv)
  cla -h | --help             # show this help
EOF
}

die() {
  echo "error: $*" >&2
  exit 1
}
want_help() { [[ "${1-}" == "-h" || "${1-}" == "--help" ]]; }

if want_help "${1-}"; then
  usage
  exit 0
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
  --podman)
    engine="podman"
    shift
    ;;
  --docker)
    engine="docker"
    shift
    ;;
  --dotenv)
    dotenv="${2:?}"
    shift 2
    ;;
  --env)
    envs+=("${2:?}")
    shift 2
    ;;
  --recreate)
    recreate=1
    shift
    ;;
  --)
    shift
    run_cmd="$*"
    use_shell=0
    break
    ;;
  *)
    run_cmd="$*"
    use_shell=0
    break
    ;;
  esac
done

# --- AUTO-INSTALL DEVCONTAINER CLI ---------------------------------
if ! command -v "$dc_bin" >/dev/null 2>&1; then
  echo "âš ï¸  devcontainer CLI not found. Attempting to install..." >&2
  
  if command -v npm >/dev/null 2>&1; then
    echo "ðŸ“¦ Installing via npm (global)..." >&2
    npm install -g @devcontainers/cli
  else
    die "devcontainer CLI not found and npm is not available. Please install npm first."
  fi
  
  # Verify installation succeeded
  if ! command -v "$dc_bin" >/dev/null 2>&1; then
    die "devcontainer CLI installation failed. Please install manually: npm i -g @devcontainers/cli"
  fi
  
  echo "âœ… devcontainer CLI installed successfully!" >&2
fi

# --- PRE-FLIGHT ----------------------------------------------------
[[ -f "$global_conf/.devcontainer/devcontainer.json" ]] || die "missing devcontainer.json at $global_conf/.devcontainer"

# Determine workspace (always current dir)
PROJECT_PATH="$(pwd)"
PROJECT_BASENAME="$(basename "$PROJECT_PATH")"

# Export envs consumed by ${localEnv:...} BEFORE 'up'
export PROJECT_PATH
export PROJECT_BASENAME

# Always set these so container hooks see them at create/start time
export CLAUDE_CODE_USE_BEDROCK=1

# Auto-inject AWS_BEARER_TOKEN_BEDROCK for container hooks
if [[ -n "${AWS_BEARER_TOKEN_BEDROCK-}" ]]; then
  export AWS_BEARER_TOKEN_BEDROCK
else
  echo "âš ï¸  warning: AWS_BEARER_TOKEN_BEDROCK not set on host; container hooks won't see it" >&2
fi

# --- BUILD RUNTIME PRELUDE -----------------------------------------
exports=() # init for set -u

# dotenv first
if [[ -n "$dotenv" ]]; then
  [[ -f "$dotenv" ]] || die "dotenv file not found: $dotenv"
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    key="${line%%=*}"
    val="${line#*=}"
    exports+=("export $key=$(printf '%q' "$val")")
  done <"$dotenv"
fi

# manual --env KEY=VALUE
for kv in "${envs[@]}"; do
  [[ "$kv" == *"="* ]] || die "--env expects KEY=VALUE (got: $kv)"
  key="${kv%%=*}"
  val="${kv#*=}"
  exports+=("export $key=$(printf '%q' "$val")")
done

# (Optional) also export for the runtime shell (not strictly needed, but nice)
exports+=("export CLAUDE_CODE_USE_BEDROCK=1")
if [[ -n "${AWS_BEARER_TOKEN_BEDROCK-}" ]]; then
  exports+=("export AWS_BEARER_TOKEN_BEDROCK=$(printf '%q' "$AWS_BEARER_TOKEN_BEDROCK")")
fi

# Compose prelude for container exec
prelude=""
if ((${#exports[@]} > 0)); then
  prelude=$(printf '%s; ' "${exports[@]}")
fi

# --- START CONTAINER -----------------------------------------------
# Use --workspace-folder to specify the workspace and --override-config to use our global config
up_args=(up --workspace-folder "$PROJECT_PATH" --override-config "$global_conf/.devcontainer/devcontainer.json" --id-label "devcontainer.local_folder=${PROJECT_PATH}")
if [[ "$engine" != "docker" ]]; then
  up_args=(--docker-path "$engine" "${up_args[@]}")
fi
if ((recreate == 1)); then
  up_args+=(--remove-existing-container)
fi

# Run the devcontainer up command
"$dc_bin" "${up_args[@]}" >/dev/null

# --- EXEC INSIDE CONTAINER -----------------------------------------
exec_args=(exec --workspace-folder "$PROJECT_PATH" --override-config "$global_conf/.devcontainer/devcontainer.json")

if [[ $use_shell -eq 1 ]]; then
  "$dc_bin" "${exec_args[@]}" bash -lc "${prelude} exec \"\${SHELL:-bash}\""
else
  [[ -n "$run_cmd" ]] || die "no command provided after --"
  "$dc_bin" "${exec_args[@]}" bash -lc "${prelude} $run_cmd"
fi
