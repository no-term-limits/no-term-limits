#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "click",
#   "requests",
#   "rich",
# ]
# ///
"""Jules API CLI wrapper - interact with Jules sessions and apply code changes."""

import json
import os
import subprocess
import tempfile
import webbrowser
from pathlib import Path
from typing import Optional

import click
import requests
from rich.console import Console
from rich.table import Table


class AliasedGroup(click.Group):
    """A click Group that allows unique prefix matching for commands."""

    def resolve_command(self, ctx, args):
        if not args:
            return super().resolve_command(ctx, args)
        
        cmd_name = args[0]
        remaining_args = args[1:]
        
        # First try exact match
        cmd = click.Group.get_command(self, ctx, cmd_name)
        if cmd is not None:
            return cmd.name, cmd, remaining_args
        
        # Find all commands that start with the prefix
        matches = [x for x in self.list_commands(ctx) if x.startswith(cmd_name)]
        
        if not matches:
            return super().resolve_command(ctx, args)
        elif len(matches) == 1:
            cmd = click.Group.get_command(self, ctx, matches[0])
            return matches[0], cmd, remaining_args
        
        # Multiple matches - check if we have more args and can disambiguate
        if remaining_args:
            # Prefer groups over commands when there are more args
            group_matches = [
                m for m in matches 
                if isinstance(click.Group.get_command(self, ctx, m), click.Group)
            ]
            if len(group_matches) == 1:
                cmd = click.Group.get_command(self, ctx, group_matches[0])
                return group_matches[0], cmd, remaining_args
        
        ctx.fail(f"Ambiguous command '{cmd_name}': could be {', '.join(sorted(matches))}")

console = Console()

JULES_API_BASE = "https://jules.googleapis.com/v1alpha"


def get_api_key() -> str:
    """Get the Jules API key from environment."""
    api_key = os.environ.get("JULES_API_KEY")
    if not api_key:
        raise click.ClickException("JULES_API_KEY environment variable not set")
    return api_key


def make_request(endpoint: str, method: str = "GET", params: Optional[dict] = None, json_data: Optional[dict] = None) -> Optional[dict]:
    """Make a request to the Jules API."""
    api_key = get_api_key()
    url = f"{JULES_API_BASE}/{endpoint}"
    headers = {"x-goog-api-key": api_key}
    if json_data:
        headers["Content-Type"] = "application/json"
    
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, params=params or {})
        elif method == "POST":
            response = requests.post(url, headers=headers, json=json_data)
        elif method == "DELETE":
            response = requests.delete(url, headers=headers)
        else:
            raise ValueError(f"Unsupported method: {method}")
        response.raise_for_status()
        return response.json() if response.text else None
    except requests.exceptions.RequestException as e:
        error_msg = str(e)
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg = f"{e}: {error_data}"
            except:
                if e.response.text:
                    error_msg = f"{e}: {e.response.text}"
        raise click.ClickException(error_msg)


def get_session_by_index(index: int = 1) -> Optional[dict]:
    """Get session by index (1 = most recent, 2 = second most recent, etc.)."""
    data = make_request("sessions", method="GET", params={"pageSize": index})
    sessions = data.get("sessions", [])
    
    if len(sessions) < index:
        return None
    
    return sessions[index - 1]


def get_session_id(session: dict) -> str:
    """Extract session ID from a session dict."""
    session_id = session.get("id")
    if session_id:
        return session_id
    
    # Fallback: extract from name field (format: "sessions/{id}")
    session_name = session.get("name", "")
    if session_name.startswith("sessions/"):
        return session_name[9:]  # len("sessions/") == 9
    
    return session_name if session_name else ""


def resolve_session(session_ref: str) -> tuple[str, Optional[dict]]:
    """Resolve a session reference to (session_id, session_info).
    
    Accepts either:
    - A direct session ID
    - Single digit 1-9: Nth most recent session (1-indexed)
    
    Returns (session_id, session_dict) or (session_ref, None) for direct IDs.
    """
    # Single digit = index into recent sessions
    if len(session_ref) == 1 and session_ref.isdigit():
        index = int(session_ref)
        if index < 1 or index > 9:
            return (session_ref, None)
        session = get_session_by_index(index)
        if session:
            return (get_session_id(session), session)
        return (session_ref, None)
    return (session_ref, None)


def format_session_info(session: dict) -> str:
    """Format session info for display."""
    title = session.get("title", "")
    source_context = session.get("sourceContext", {})
    branch = source_context.get("githubRepoContext", {}).get("startingBranch", "")
    parts = []
    if title:
        parts.append(f'"{title}"')
    if branch:
        parts.append(f"[{branch}]")
    return " ".join(parts) if parts else ""


def resolve_session_id_from_args(session_ref: str) -> str:
    """Resolve session reference and exit with error if not found."""
    is_index = len(session_ref) == 1 and session_ref.isdigit()
    
    session_id, session_info = resolve_session(session_ref)
    
    if is_index and not session_info:
        raise click.ClickException(f"Could not find session #{session_ref}")
    
    if session_info:
        info_str = format_session_info(session_info)
        if info_str:
            console.print(f"[green]Session #{session_ref}: {info_str}[/green]")
        else:
            console.print(f"[green]Session #{session_ref}: {session_id}[/green]")
    
    return session_id


def get_sources() -> list:
    """Get list of available sources."""
    data = make_request("sources", method="GET", params={"pageSize": 100})
    return data.get("sources", [])


def print_json(data):
    """Pretty print JSON data."""
    console.print(json.dumps(data, indent=2))


def list_repos():
    """List all available repos."""
    console.print("[bold]Fetching repos (sources)...[/bold]")
    
    sources = get_sources()
    
    if not sources:
        console.print("[yellow]No repos found[/yellow]")
        return
    
    table = Table(title="Available Sources")
    table.add_column("Source", style="cyan")
    
    for source in sources:
        source_name = source.get("name", "N/A")
        table.add_row(source_name)
    
    console.print(table)


def delete_session(session_id: str, quiet: bool = False):
    """Delete a session."""
    make_request(f"sessions/{session_id}", method="DELETE")
    if not quiet:
        console.print(f"[green]✓ Session {session_id} deleted[/green]")


def list_sessions(limit: int = 30):
    """List all sessions."""
    console.print("[bold]Fetching sessions...[/bold]")
    
    data = make_request("sessions", method="GET", params={"pageSize": limit})
    sessions = data.get("sessions", [])
    
    if not sessions:
        console.print("[yellow]No sessions found[/yellow]")
        return
    
    table = Table(title="Jules Sessions")
    table.add_column("Session ID", style="cyan")
    table.add_column("Title", style="green")
    table.add_column("Branch", style="magenta")
    table.add_column("State", style="yellow")
    table.add_column("Created", style="blue")
    
    for session in sessions:
        session_id = session.get("name", "").replace("sessions/", "")
        title = session.get("title", "N/A")
        source_context = session.get("sourceContext", {})
        branch = source_context.get("githubRepoContext", {}).get("startingBranch", "N/A")
        state = session.get("state", "UNKNOWN")
        created = session.get("createTime", "N/A")
        table.add_row(session_id, title, branch, state, created)
    
    console.print(table)


def list_activities(session_id: str, limit: int = 60):
    """List activities for a session."""
    console.print(f"[bold]Fetching activities for session {session_id}...[/bold]")
    
    endpoint = f"sessions/{session_id}/activities"
    data = make_request(endpoint, method="GET", params={"pageSize": limit})
    activities = data.get("activities", [])
    
    if not activities:
        console.print("[yellow]No activities found[/yellow]")
        return
    
    table = Table(title=f"Activities for Session {session_id}")
    table.add_column("Activity ID", style="cyan")
    table.add_column("Originator", style="green")
    table.add_column("Type", style="yellow")
    table.add_column("Has Artifacts", style="magenta")
    table.add_column("Created", style="blue")
    
    for activity in activities:
        activity_id = activity.get("id", "N/A")
        originator = activity.get("originator", "N/A")
        
        # Determine activity type
        activity_type = "unknown"
        if "agentMessaged" in activity:
            activity_type = "agent_message"
        elif "userMessaged" in activity:
            activity_type = "user_message"
        elif "planGenerated" in activity:
            activity_type = "plan_generated"
        elif "planApproved" in activity:
            activity_type = "plan_approved"
        elif "progressUpdated" in activity:
            activity_type = "progress_updated"
        elif "sessionCompleted" in activity:
            activity_type = "session_completed"
        elif "sessionFailed" in activity:
            activity_type = "session_failed"
        
        has_artifacts = "✓" if activity.get("artifacts") else ""
        created = activity.get("createTime", "N/A")
        
        table.add_row(activity_id, originator, activity_type, has_artifacts, created)
    
    console.print(table)
    
    # Show summary of artifacts
    artifact_count = sum(1 for a in activities if a.get("artifacts"))
    if artifact_count > 0:
        console.print(f"\n[green]Found {artifact_count} activities with artifacts[/green]")


def apply_git_patch(patch_content: str, base_commit: Optional[str] = None) -> bool:
    """Apply a git patch to the current repository."""
    # Check if we're in a git repository
    try:
        subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            check=True,
            capture_output=True,
            text=True
        )
    except subprocess.CalledProcessError:
        console.print("[red]Error: Not in a git repository[/red]")
        return False
    
    # Optionally check base commit
    if base_commit:
        try:
            result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                check=True,
                capture_output=True,
                text=True
            )
            current_commit = result.stdout.strip()
            if not current_commit.startswith(base_commit[:7]):
                console.print(
                    f"[yellow]Warning: Current commit {current_commit[:7]} "
                    f"doesn't match base commit {base_commit[:7]}[/yellow]"
                )
        except subprocess.CalledProcessError:
            pass
    
    # Write patch to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False) as f:
        f.write(patch_content)
        patch_file = f.name
    
    try:
        # Apply the patch
        result = subprocess.run(
            ["git", "apply", "--verbose", patch_file],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            console.print("[green]✓ Patch applied successfully[/green]")
            if result.stdout:
                console.print(result.stdout)
            return True
        else:
            console.print("[red]✗ Failed to apply patch[/red]")
            if result.stderr:
                console.print(f"[red]{result.stderr}[/red]")
            return False
    finally:
        # Clean up temporary file
        Path(patch_file).unlink(missing_ok=True)


def get_default_source() -> Optional[str]:
    """Get the default source if only one exists."""
    sources = get_sources()
    if len(sources) == 1:
        return sources[0].get("name")
    return None


def create_session(
    prompt: str,
    source: Optional[str],
    branch: str = "main",
    title: Optional[str] = None,
    require_plan_approval: bool = False,
    auto_create_pr: bool = False
):
    """Create a new Jules session."""
    console.print("[bold]Creating new session...[/bold]")
    
    # Auto-detect source if not provided
    if not source:
        source = get_default_source()
        if source:
            console.print(f"[green]Auto-detected source: {source}[/green]")
        else:
            sources = get_sources()
            if not sources:
                raise click.ClickException("No sources available. Add a source first.")
            else:
                source_list = "\n".join(f"  - {s.get('name')}" for s in sources)
                raise click.ClickException(f"--source is required (multiple sources available)\nAvailable sources:\n{source_list}")
    
    # Build request body
    request_body = {
        "prompt": prompt,
        "sourceContext": {
            "source": source,
            "githubRepoContext": {
                "startingBranch": branch
            }
        },
        "requirePlanApproval": require_plan_approval
    }
    
    if title:
        request_body["title"] = title
    
    if auto_create_pr:
        request_body["automationMode"] = "AUTO_CREATE_PR"
    
    # Make the request
    data = make_request("sessions", method="POST", json_data=request_body)
    
    # Display the created session
    session_name = data.get("name", "")
    session_id = data.get("id", "")
    session_title = data.get("title", "N/A")
    session_state = data.get("state", "UNKNOWN")
    session_url = data.get("url", "")
    
    console.print("\n[green]✓ Session created successfully![/green]\n")
    
    table = Table(show_header=False)
    table.add_column("Field", style="cyan")
    table.add_column("Value", style="white")
    
    table.add_row("Session ID", session_id)
    table.add_row("Name", session_name)
    table.add_row("Title", session_title)
    table.add_row("State", session_state)
    table.add_row("URL", session_url)
    
    console.print(table)
    console.print(f"\n[yellow]You can view this session at: {session_url}[/yellow]")
    console.print(f"[yellow]To apply changes later, run: jul apply {session_id}[/yellow]")


def send_message(session_id: str, prompt: str):
    """Send a message to a session."""
    endpoint = f"sessions/{session_id}:sendMessage"
    make_request(endpoint, method="POST", json_data={"prompt": prompt})
    console.print(f"[green]✓ Message sent to session {session_id}[/green]")


def apply_artifacts(session_id: str):
    """Find the last activity with git patch artifacts and apply it."""
    console.print(f"[bold]Fetching activities for session {session_id}...[/bold]")
    
    endpoint = f"sessions/{session_id}/activities"
    data = make_request(endpoint, method="GET", params={"pageSize": 100})
    activities = data.get("activities", [])
    
    if not activities:
        console.print("[yellow]No activities found[/yellow]")
        return
    
    # Find the LAST activity with a changeSet artifact (most recent iteration)
    last_patch = None
    for activity in reversed(activities):  # Process in reverse to find the last one
        artifacts = activity.get("artifacts", [])
        for artifact in artifacts:
            if "changeSet" in artifact:
                change_set = artifact["changeSet"]
                git_patch = change_set.get("gitPatch")
                if git_patch:
                    last_patch = {
                        "activity_id": activity.get("id"),
                        "base_commit": git_patch.get("baseCommitId"),
                        "patch": git_patch.get("unidiffPatch"),
                        "commit_message": git_patch.get("suggestedCommitMessage"),
                    }
                    break
        if last_patch:
            break
    
    if not last_patch:
        console.print("[yellow]No git patches found in activities[/yellow]")
        return
    
    if not last_patch['patch']:
        console.print("[yellow]Found a changeSet but it has no patch content (plan-only activity?)[/yellow]")
        if last_patch['commit_message']:
            console.print(f"Suggested commit message: {last_patch['commit_message']}")
        return
    
    console.print(f"\n[bold]Applying the most recent patch from the session[/bold]\n")
    console.print(f"Activity ID: {last_patch['activity_id']}")
    if last_patch['commit_message']:
        console.print(f"Suggested commit message: {last_patch['commit_message']}")
    console.print()
    
    # Apply the patch
    if apply_git_patch(last_patch['patch'], last_patch['base_commit']):
        console.print("\n[green]Changes have been applied to your working directory.[/green]")
        console.print("[yellow]Review the changes with 'git diff' and commit when ready.[/yellow]")
    else:
        console.print("\n[red]Failed to apply patch[/red]")


@click.group(cls=AliasedGroup)
def cli():
    """Jules API CLI - interact with Jules sessions and apply code changes."""
    pass


@cli.group(cls=AliasedGroup)
def session():
    """Manage Jules sessions."""
    pass


@session.command("list")
@click.option("--limit", default=30, help="Maximum number of sessions to list")
def session_list(limit):
    """List all sessions."""
    list_sessions(limit)


@session.command("detail")
@click.argument("session_ref")
def session_detail(session_ref):
    """Show session details as JSON. SESSION_REF can be an ID or 1-9 for Nth most recent."""
    print_json(make_request(f"sessions/{resolve_session_id_from_args(session_ref)}"))


@session.command("open")
@click.argument("session_ref", default="1")
def session_open(session_ref):
    """Open session in browser. SESSION_REF can be an ID or 1-9 for Nth most recent (default: 1)."""
    data = make_request(f"sessions/{resolve_session_id_from_args(session_ref)}")
    webbrowser.open(data.get("url", ""))


@session.command("rm")
@click.argument("session_ref")
def session_rm(session_ref):
    """Remove/delete a session. SESSION_REF can be an ID or 1-9 for Nth most recent."""
    session_id = resolve_session_id_from_args(session_ref)
    delete_session(session_id, quiet=True)
    console.print(f"[green]✓ Deleted[/green]")


@session.command("create")
@click.option("--prompt", required=True, help="Task description for Jules")
@click.option("--source", help="Source repository (auto-detected if only one)")
@click.option("--branch", default="main", help="Starting branch")
@click.option("--title", help="Optional title for the session")
@click.option("--require-plan-approval/--no-require-plan-approval", default=False)
@click.option("--auto-create-pr", is_flag=True, help="Automatically create PR when ready")
def session_create(prompt, source, branch, title, require_plan_approval, auto_create_pr):
    """Create a new Jules session."""
    create_session(prompt, source, branch, title, require_plan_approval, auto_create_pr)


@session.command("message")
@click.argument("session_ref")
@click.argument("prompt")
def session_message(session_ref, prompt):
    """Send a message to a session. SESSION_REF can be an ID or 1-9 for Nth most recent."""
    send_message(resolve_session_id_from_args(session_ref), prompt)


@cli.group(cls=AliasedGroup)
def repo():
    """Manage repos."""
    pass


@repo.command("list")
def repo_list():
    """List all available repos."""
    list_repos()


@repo.command("detail")
@click.argument("source_name")
def repo_detail(source_name):
    """Show source details as JSON."""
    print_json(make_request(source_name))


@cli.group(cls=AliasedGroup)
def activity():
    """Manage session activities."""
    pass


@activity.command("list")
@click.argument("session_ref")
@click.option("--limit", default=60, help="Maximum number of activities to list")
def activity_list(session_ref, limit):
    """List activities for a session. SESSION_REF can be an ID or 1-9 for Nth most recent."""
    list_activities(resolve_session_id_from_args(session_ref), limit)


@activity.command("detail")
@click.argument("session_ref")
@click.argument("activity_id")
def activity_detail(session_ref, activity_id):
    """Show activity details as JSON."""
    session_id = resolve_session_id_from_args(session_ref)
    print_json(make_request(f"sessions/{session_id}/activities/{activity_id}"))


@cli.command()
@click.argument("session_ref", default="1")
def apply(session_ref):
    """Apply git patches from a session. SESSION_REF can be an ID or 1-9 for Nth most recent (default: 1)."""
    apply_artifacts(resolve_session_id_from_args(session_ref))


if __name__ == "__main__":
    cli()
